# Scoring System — учебный проект

## Описание проекта

Данный проект представляет собой упрощённую модель системы скоринга (оценки платёжеспособности клиента) в банке.  
Система состоит из набора правил, каждое из которых оценивает определённые аспекты поведения клиента: его активность, кредитную историю, наличие обращений, структуру расходов и т.д.

Результаты всех правил используются для формирования общего профиля риска клиента.  
Каждое правило возвращает значение риска:
- `HIGH` — высокий риск неплатёжеспособности;
- `MEDIUM` — средний риск;
- `LOW` — низкий риск.

---

## Структура проекта

### 1. Модели данных
В проекте определены основные сущности:
- **Client** — данные клиента (ФИО, возраст, регион);
- **Account** — банковские счета клиента (тип, баланс, валюта);
- **Transaction** — операции по счетам (доходы и расходы);
- **Loan** — кредиты клиента;
- **Overdue** — просрочки по кредитам;
- **Ticket** — обращения клиента в службу поддержки.

Каждая сущность оформлена в виде `data class`.

---

### 2. Репозитории

Репозитории отвечают за хранение и предоставление данных.  
Используются простые реализации на основе памяти:

- `InMemoryAccountRepository`
- `InMemoryTransactionRepository`
- `InMemoryLoanRepository`
- `InMemoryOverdueRepository`
- `InMemoryTicketRepository`

Каждый репозиторий реализует интерфейс с методом `get...`, возвращающим коллекцию данных по идентификатору клиента.

Пример:
```kotlin
val transactions = transactionRepo.getTransactions(client.id)
```

---

### 3. Интерфейс правил скоринга

Каждое правило реализует интерфейс `ScoringRule`:

```kotlin
interface ScoringRule {
    val ruleName: String
    fun evaluate(client: Client): ScoringResult
}
```
Метод `evaluate` выполняет анализ данных клиента и возвращает результат:

```kotlin
data class ScoringResult(
    val ruleName: String,
    val score: PaymentRisk
)
```
Где `PaymentRisk` — это перечисление, определяющее уровень риска:
```kotlin
enum class PaymentRisk {
    HIGH, MEDIUM, LOW
}
```

### 4. Пример реализованного правила

В проекте уже реализован пример правила, которое можно использовать как ориентир - `LargeTransactionFrequencyRule`

## Задание 

### 1. Ознакомиться с системой

- Изучите модели данных (`Client`, `Account`, `Transaction`, `Loan`, `Ticket`, `Overdue`);
- Ознакомьтесь с интерфейсом ScoringRule и принципом его реализации;
- Посмотрите пример уже готового правила, чтобы понять подход.

### Ограничения

Если реализация правила будет нарушать ограничение, то оно будет оценено в 0 баллов. 

В реализации правил **запрещено использовать функциональные методы обработки коллекций**, такие как:

`map`, `filter`, `forEach`, `flatMap`, `groupBy`, `any`, `all`, `none`, `sumOf`, `average` и т.д.

Вместо этого необходимо использовать **обычные императивные конструкции**:

- циклы (`for`, `while`);
- условные операторы (`if`, `when`);
- переменные для накопления промежуточных результатов (`var total = 0`, `var count = 0` и т.д.).

> **Цель:**  
> Научиться понимать, как работают базовые алгоритмы обхода коллекций вручную, без синтаксического сахара Kotlin.


### 2. Реализовать недостающие правила

В коде присутствуют классы-заготовки для правил с пометкой TODO() — их необходимо реализовать.

Каждое правило должно:
- Извлекать нужные данные из репозиториев;
- Анализировать информацию с использованием функций работы с коллекциями;
- Возвращать объект ScoringResult с уровнем риска.

### 3. Дополнительное задание (необязательно)

Реализуйте собственное правило скоринга по аналогии с уже существующими.