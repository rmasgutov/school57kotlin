# Объектное-ориентированное программирование в Kotlin

## Введение в ООП

### Концепция
- Понятие объектно-ориентированного программирования.
- Основные принципы ООП: инкапсуляция, наследование, полиморфизм.
- Наследование vs композиция

### Классы и объекты
- Определение класса и создание объектов.
- Поля и методы класса.
- Конструкторы класса.
- Статические члены класса.

### Инкапсуляция
- Понятие инкапсуляции.
- Модификаторы доступа (`private`, `protected`, `internal`, `public`).
- Использование геттеров и сеттеров для управления доступом к полям.

### Наследование
- Понятие наследования.
- Базовый класс и производные классы.
- Переопределение методов базового класса.
- Абстрактные классы и интерфейсы.

### Полиморфизм
- Понятие полиморфизма.
- Перегрузка методов.
- Переопределение методов.
- Виртуальные методы и абстрактные классы.

### Интерфейсы
- Понятие интерфейса.
- Реализация интерфейсов.
- Множественное наследование интерфейсов.

## Классы Kotlin

### Объявление классов
- Синтаксис объявления классов.
- Создание экземпляров классов.

### Методы и свойства
- Объявление методов и свойств.
- Модификаторы доступа.
- Статические методы и свойства.

### Конструкторы
- Объявление конструкторов.
- Первичный конструктор.
- Вторичные конструкторы.

### Наследование
- Наследование от классов и интерфейсов.
- Переопределение методов.

### Абстрактные классы и интерфейсы
- Абстрактные классы и методы.
- Интерфейсы и их реализация.

### Объекты-компаньоны
- Объявление объектов-компаньонов.
- Доступ к методам и свойствам класса.

### Вложенные классы
- Объявление вложенных классов.
- Доступ к членам внешнего класса.

### Анонимные классы
- Создание анонимных классов.
- Использование анонимных классов.

### Data classes
- Объявление data classes.
- Автоматическое создание методов `equals()`, `hashCode()`, `toString()`.

### Sealed classes
- Объявление sealed classes.
- Ограничение наследования.

### Проверка типов

------------------------------------

## Задания

### "Майнкрафт"
#### Описание
> Создайте классы персонажей игры.
1. Создайте абстрактный класс персонажа `Character` с полями: позицией `x`/`y`, имя `name`, признаком NPC `isBot` и методом `say`, который выводит в консоль "Hi!".
2. Создайте 2 наследника класса `Character`: `Hero`(игровой персонаж) и `Monster`(бот).
3. В классе `Hero` переопределите метод `say`, который выводит в консоль "I'm a hero!" + имя. Необходимо использовать string templates.
4. В классе `Hero` добавьте поле `hasBoots`
5. Создайте вторичный конструктор для каждого наследника, который устанавливает соответствующее значение в признак NPC и устанавливает случайную позицию.
6. Создайте интерфейс `Moveable` с методом `move`.
7. Реализуйте интерфейс `Moveable` для классов `Hero` и `Monster`, который принимает на вход изменение координат `dx`/`dy` и выводит в консоль "I'm moving to x/y", где x/y вычисленные значения на основе текущей позиции.
8. Класс `Hero`, который имеет свойство `hasBoots=true` двигается дважды

------------------------------------
### "Разработка системы учёта товаров"
#### Описание
> Создайте систему учёта товаров в магазине. Система должна включать следующие классы:
>
> Product – дата-класс товара с полями для названия - `name`, цены - `price` и количества - `count`. 
> Измените метод equals так, чтобы сравнивались только названия товаров, без учета цены и количества.
> Переопределите оператор сложения, так что бы товары, которые имеют одинаковое названия складывались в один товар с суммарным количеством.  
> 
> Category – абстрактный класс категории товара. Имеет наследников: FoodCategory, ElectronicsCategory. 
> Все категории товаров имеют свойства название - `name` и список товаров - `products`. 
> Классы имеют метод поиска товаров - `findProducts(String)`, который на вход получает строку поиска и ищет по вхождению строки в названии товара или в названии категории.
> Если строка найдена в названии категории, то необходимо вывести все товары из категории.
> Если товаров нет, то возвращается пустой список.
> Метод проведения инвентаризации товаров в категории - `inventoryManagement()`, который объединяет все товары с одним именем и суммирует количество. 
> 
> Store – object класс магазина с методами для пополнения товаров - `topUp(list Category)`, продажи - `sell(Product)` и поиска товаров - `search(String)`.
> У класса есть свойство `sales` - список проданных товаров и `warehouse` - склад, который представлен списком категорий.
> Особенность метода `sell`, при продаже товара, он должен уменьшаться на заданное количество. 
> При продаже продуктов питания действует правило, что всегда продается в 2 раза больше товаров от изначального запроса.
> При продаже электроники действует правило, что всегда продается по одному товару. 
> 
> Реализуйте методы для добавления, удаления и изменения товаров в магазине, а также для расчёта общей стоимости товаров в определённой категории.


#### Ограничения
* Используйте class, data class, object
* Используйте наследование
* Используйте несколько конструкторов в одном классе
